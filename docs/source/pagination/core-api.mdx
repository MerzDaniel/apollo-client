---
title: Core pagination API
sidebar_title: Core API
description: Fetching and caching paginated results
---

The Apollo Client APIs described in this article are useful for handling all paginated list fields, regardless of which pagination strategy a field uses.

## The `fetchMore` function

Pagination always involves sending followup queries to your GraphQL server to obtain additional pages of results. In Apollo Client, the recommended way to send these followup queries is with the [`fetchMore`](../caching/advanced-topics/#incremental-loading-fetchmore) function. This function is a member of the `ObservableQuery` object returned by `client.watchQuery`, and it's also included in the object returned by the `useQuery` hook:

```js
const { loading, data, fetchMore } = useQuery(GET_ITEMS, { //highlight-line
  variables: {
    offset: 0,
    limit: 10
  },
});
```

When you then call `fetchMore`, you can provide a new set of `variables` in the function's `options` object (such as a new `offset`):

```js
fetchMore({
  variables: {
    offset: 10,
    limit: 10
  },
});
```

You can also optionally provide an entirely different shape of `query` to execute (by default, the original query's shape is used).

> In Apollo Client 2, you would also provide `fetchMore` an `updateQuery` function, which was responsible for merging the followup query's results with your existing cached data. In Apollo Client 3, you instead [define custom `merge` functions](#merging-paginated-results). This enables you to specify all of your pagination logic in a central location, instead of duplicating it everywhere you call `fetchMore`.

Full examples of using `fetchMore` are provided in the detailed documentation for [offset-based pagination](./offset-based) and [cursor-based pagination](./cursor-based). The rest of this article covers the field policy configuration API that enables `fetchMore` to ignore how followup query results are cached.

## Merging paginated results

> The example below uses offset-based pagination, but this article applies to all pagination strategies.

To specify which page of a list field you want to fetch, you usually set the value of an argument for that field, such as `offset` or `cursor`. This argument's value is different for each query that fetches a different page of the list.

Because the argument values for these queries are different, Apollo Client treats the _results_ of the queries as different (by default). The result of each query is stored as an entirely separate entity in the cache, and each entity includes the argument values in its unique identifier.

Although this argument-based separation is helpful in most cases, it usually _isn't_ what you want when implementing pagination. Instead, you want all returned pages to be merged into a _single_ list in your cache. To achieve this, you can configure a **field policy** for the paginated field.

### Defining a field policy

A field policy specifies how a particular field in your Apollo Client cache is read and written. You can define a field policy to merge the results of paginated queries into a single list.

#### Example

Here's the server-side schema for a message feed application that uses offset-based pagination:

```graphql{2}
type Query {
  feed(offset: Int, limit: Int): [FeedItem!]
}

type FeedItem {
  id: String!
  message: String!
}
```

In our client, we want to define a field policy for `Query.feed` so that all returned pages of the list are merged into a _single_ list in our cache.

We define our field policy within the `typePolicies` option we provide the constructor of `InMemoryCache`:

```js{5-15}
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          // Don't cache separate results based on 
          // any of this field's argument values.
          keyArgs: [],

          // Combine the incoming list items with the
          // existing list items.
          merge(existing = [], incoming) {
            return [...existing, ...incoming];
          },
        }
      }
    }
  }
})
```

This field policy defines a list of **`keyArgs`**, along with a **`merge` function**. Both of these are necessary for handling pagination:

* `keyArgs` lists each argument that causes the cache to store a _separate_ result based on that argument's value. In this case, the cache shouldn't store a separate result based on either `offset` _or_ `limit`, so the list is empty.
  * Whenever a particular argument's value could cause items from an _entirely different list_ to be returned for the field, that argument _should_ be included in `keyArgs`.
  * For more information, see [Specifying key arguments](../caching/cache-field-behavior/#specifying-key-arguments).
* A `merge` function tells the Apollo Client cache how to combine `incoming` data with `existing` cached data for a particular field. Without this function, a followup query _overwrites_ the existing cached value by default.
  * For more information, see [The `merge` function](../caching/cache-field-behavior/#the-merge-function).

With this field policy in place, Apollo Client merges the results of all queries that use the following structure, regardless of argument values:

```ts
// Client-side query definition
const FEED_QUERY = gql`
  query Feed($offset: Int, $limit: Int) {
    feed(offset: $offset, limit: $limit) {
      id
      message
    }
  }
`;
```

### Designing the `merge` function

In [the example above](#example), our `merge` function is a single line:

```js
merge(existing = [], incoming) {
  return [...existing, ...incoming];
}
```

This function makes risky assumptions about the order in which the client requests pages, because it ignores the values of `offset` and `limit`. A more robust `merge` function can use `options.args` to decide where to put `incoming` data relative to `existing` data, like so:

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          keyArgs: [],
          merge(existing, incoming, { args: { offset = 0 }}) {
            // Slicing is necessary because the existing data is
            // immutable, and frozen in development.
            const merged = existing ? existing.slice(0) : [];
            for (let i = 0; i < incoming.length; ++i) {
              merged[offset + i] = incoming[i];
            }
            return merged;
          },
        },
      },
    },
  },
});
```

This logic handles sequential page writes the same way the single-line strategy does, but it can also tolerate repeated, overlapping, or out-of-order writes, without duplicating any list items.

## Two kinds of `read` function

Now that you understand the basics of `merge` functions, you may be wondering about the other direction cache data can flow: what happens when you _read_ from a paginated field?

Just as a `merge` function uses field arguments to control how paginated data is reassembled from individual pages, producing a single combined list of internal cache data, a custom `read` function has the opportunity to translate that internal list back into individual pages, again using field arguments to select the page in question, possibly even sorting or filtering the data, depending on what other arguments you choose to implement. This capability goes beyond returning the same pages that were originally received, since a `read` function for `offset`/`limit` pagination could read from any available `offset`, with any desired `limit`:

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          read(existing, { args: { offset, limit }}) {
            // Important to return undefined when existing is undefined,
            // rather than defaulting to an empty array, because returning
            // undefined is how a read function signals that the field is
            // missing, causing the query to be fetched from the network.
            return existing && existing.slice(offset, offset + limit);
          },

          // The keyArgs and merge configurations are the same as above.
          keyArgs: ["type"],
          merge(existing, incoming, { args: { offset = 0 }}) {
            const merged = existing ? existing.slice(0) : [];
            for (let i = 0; i < incoming.length; ++i) {
              merged[offset + i] = incoming[i];
            }
            return merged;
          },
        },
      },
    },
  },
});
```

Depending on the assumptions you feel comfortable making, you may wish to make this code more defensive. For example, you might want to provide default values for the `offset` and `limit` arguments, in case someone tries to access the `Query.feed` field without using the appropriate arguments:

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          read(existing, {
            args: {
              // Default to returning the whole array, if the offset and
              // limit arguments are not provided.
              offset = 0,
              limit = existing?.length,
            } = {},
          }) {
            return existing && existing.slice(offset, offset + limit);
          },
          // ... keyArgs, merge ...
        },
      },
    },
  },
});
```

This style of `read` function, which takes responsibility for re-paginating your data based on the field arguments, essentially inverts the behavior of the `merge` function, so your application can query different pages using different arguments.

**However, this is not the only way to write a `read` function!**

Another reasonable approach to writing a `read` function for a paginated field like `Query.feed` is to _ignore_ the `offset` and `limit` arguments, and always return the entire list, so your application code can take responsibility for slicing the list into pages, depending on how you want to display the data in different parts of the application.

If you adopt this second approach, you may discover you don't even need a `read` function, because you no longer need to examine the `args` or slice the `existing` data before returning it. That's why the `offsetLimitPagination` helper we mentioned above is implemented without a `read` function.

> When you provide both a `merge` function and `read` function, `keyArgs: false` will be assumed by default (though it can be overridden to something else, like `keyArgs: ["type"]`). However, if you provide only a `merge` function (or only a `read` function), you should specify `keyArgs` explicitly, to override the default behavior of considering all arguments relevant.

The right approach will vary from field to field, but the simpler second kind of `read` function often works best for infinitely scrolling feeds, since it gives your application code full control over which elements are displayed at any given time, without requiring any additional cache reads.
